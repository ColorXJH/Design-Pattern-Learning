package com.master.chapter004;

/**
 * @author ColorXJH
 * @version 1.0
 * @description 里氏替换原则
 * @date 2021/2/23 11:17
 */
public class LisReplacePrinciple1 {
    public static void main(String[] args) {
        A a=new A();
        System.out.println("11-3= "+a.func1(11,3));
        System.out.println("1-8= "+a.func1(1,8));
        System.out.println("----------------------------");
        B b =new B();
        System.out.println("11-3= "+b.func1(11,3));
        System.out.println("1-8= "+b.func1(1,8));
        System.out.println("11+3+9= "+b.func2(11,3));
    }
}

//OO中的继承性的思考和说明
//1：继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求
//所有的子类必须遵循这些契约，但是如果子类对这些已经实现了的方法任意修改，就会对整个继承体系造成破坏

//2：继承在给程序设计带来便利的同时，也带来了弊端，比如使用继承会给程序带来侵入性。程序的可移植性降低，
//增加对象间的耦合性，如果一个类被其他类所继承，则当这个类需要修改时，必须考虑到所有的子类，而且父类修改后，
//所有涉及到子类的功能都有可能产生故障，

//3：问题提出：在编程中，如何正确的使用继承？==》里氏替换原则


//基本介绍：
//1：Liskow Substitution Princicle 在1988由麻省理工学院一位姓李的女士提出
//2：如果对每个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有
    //的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型，换句话说
    //所有引用基类的地方必须能透明的使用其子类的对象
//3：在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
//4：里氏替换原则告诉我们，继承实际上让两个类的耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题


//来看下面问题：
class A {
    public int func1(int a,int b){
        return a-b;

    }}

class B extends A{
    //子类重写了父类的方法，不符合里氏替换原则了
    public int func1(int a,int b){
        return a+b;
    }
    public int func2(int a,int b){
        return func1(a,b)+9;
    }
}
//解决方法：
//1：我们发现原来正常运行的功能发生了错误，原因就是B类无意中重写了父类的方法，造成原有功能出现错误
//在实际编程过程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但是整个继承体系的
//复用性会比较差，特别是运行多态比较频繁的时候

//2：通常的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合关系代替

